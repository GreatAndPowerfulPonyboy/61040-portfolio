#### [Return to README](../README.md#problem-set-one-reading-and-writing-concepts)
**Concept** Url Shortener

**Purpose** Improve branding and trackability by reducing url length

**Principle** After sending a url, a user can either choose a different url or have one autogenerated.

Then, a user can send others their new shortened url that will redirect to the original url.

**State**

A set of Users with
    a count Number
    a set of String redirects

A set of String URLs with
    A set of String redirects

**Actions**

GenerateRedirect(user: User, url: String, redirect: String|None) : (redirect: String)

**requires** user is in the set of Users, redirect is not in the set of redirects. user's count is nonnegative

**effects** Decrements user's count of allowed redirects. Creates and returns a redirect string, which is either defined by the user or autogenerated if no redirect string was sent in. Adds a mapping of the redirect to the original URL.

UpdateRedirect(user:User, redirect: String, url: String) : (redirect:string)

**requires** user is in the set of users. Redirect is in user's set of redirects.

**effects** Create a new redirect pointing to url and update the mapping of urls and redirects so the old redirect points to the new redirect.

One of the subtleties of my definition is the separation of the user's ownership of a set of redirects to the set of urls ownership of a set of redirects. My intention with this was to indicate that one redirect cannot point to more than one original url, but multiple redirects can point to the same url. 

**Concept** Conference Room Booking

**Purpose** Lets users reserve conference rooms 

**Principle**
    A user can select a room they want to reserve,
    the date and time of that reservation,
    the name of their reservation,
    and a note on that reservation.
    This reservation request will be checked against availability by the system.
    The user may edit or delete the reservation, and the system will verify and update accordingly

**State**
A set of Reservations with
a Date date
a Time time
a String room
a String name
a String note

A set of users with
a set of Reservations

**Actions**

ReserveRoom(user: User, room:String, name: String, note: String, time:Time,  date:Date): (reservation: Reservation)

**requires** User is in the set of users. There is not a preexisting reservation by any user in the set of users in room at the same date and time. There is not an overlapping reservation for the given room.

**effects** Creates and returns a new reservation owned by user

UpdateReservation(user: User, reservation: Reservation, date: Date, time: Time, name: String, note:String): (reservation:Reservation)

**requires** User is in the set of users. Reservation is owned by user. Date, time, and room do not overlap with a preexisting reservation such that there is another reservation in the room at the same date and time by any user. 

**effects** Creates and returns a new reservation with updated details owned by user, deletes previous reservation

RemoveReservation(user: User, reservation: Reservation): (user: User)

**requires** user is in the set of Users, reservation is owned by user and in the set of Reservations

**effects** removes reservation from the set of Reservations, returns the

**Concept** Address Verification

**Purpose** Authenticate user location to grant access

**Principle** A user sends a set of address information claiming to be from the address they send

that information is checked against some external source to grant access

**State**

A set of Users with 
a set of String addresses with a flag Verified

**Actions**

SubmitAddress(user: User, address: Address): (user: User)

**requires** User exists in the set of Users

**effects** Add the address to the user's addresses with flag set to false

VerifyAddress(user: User, address:Address)

**requires** User exists in the set of users and address is within user's set of addresses

**effects** If the address is confirmed, set the address' Verified flag to true

The subtlety of Address Verification is that the verification details are outside of the state that we care about. Moreover, while its concept is similar to PasswordAuthentication, the primary difference in purpose is to confirm a kind of claim. The user is claiming to belong to a certain location in order to access a resource, and this concept's purpose is to verify that assertion. Thus, I didn't include some global set of addresses in the state and used a flag within the Address type to distinguish between confirmed and purported addresses for a user.